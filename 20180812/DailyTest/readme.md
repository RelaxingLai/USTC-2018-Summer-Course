##	2018.08.12晚19:00到22:00实验课内容 --- 进程同步和通信

本篇还有较多不完善的地方，欢迎补充

1.	实验步骤

	*	设计并实现一个进程，该进程拥有一个生产者线程和一个消费者线程，它们使用N个不同的缓冲区（N为一个确定的数值，例如N=32）

	*	方案一: 使用信号量

		一个互斥信号量，用以阻止生产者线程和消费者线程同时操作缓冲区列表；

		一个信号量，当生产者线程生产出一个物品时可以用它向消费者线程发出信号

		一个信号量，消费者线程释放出一个空缓冲区时可以用它向生产者线程发出信号。

	*	可考虑其他方案（共享内存、阻塞队列、互斥锁等）

	<br>

###	Linux 多线程 信号量 pv 参考

1.	https://www.cnblogs.com/zhuyijie/p/6464551.html

	信号量的函数都以 `sem_` 开头，线程中使用的基本信号量函数有4个，它们都声明在头文件 `semaphore.h` 中

	*	`sem_init(sem_t * sem, int pshared, unsigned int value)`

		该函数用于创建信号量。初始化一个定位在 `sem` 的匿名信号量

		`value` 参数指定信号量的初始值

		`pshared` 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 `pshared` 的值为 `0`, 那么信号量将被进程内的线程共享，并且应该放置在所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)

	*	`sem_wait(sem_t * sem)`

		以原子操作的方式将信号量 `sem` 的值 `减1`。但它永远会先等待该信号量为一个非零值才开始做减法。

		也就是说，如果你对一个值为2的信号量调用 `sem_wait()`, 线程将会继续执行

		如果有两个线程都在sem_wait()中等待同一个信号量变成非零值，那么当它被第三个线程增加一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态

		解除阻塞后将 `sem` 的值减一，表明公共资源经使用后减少

	*	`sem_post(sem_t * sem)`

		以原子操作的方式将信号量 `sem` 的值 `加1`

		用来增加信号量的值当有线程阻塞在这个信号量上时，调用这个函数会使其中的一个线程不再阻塞，选择机制同样是由线程的调度策略决定的。它信号量的值加1同时发出信号来唤醒等待的线程。

	*	`sem_destroy(sem_t * sem)`

		释放信号量 `sem`

	<br>

2.	https://blog.csdn.net/zzhongcy/article/details/19815513

	*	信号量被广泛用于进程与线程的同步与互斥

		信号量本质是一个非负的整数计数器，被用来控制对公共资源的访问

	*	`PV` 原子操作是对整数计数器信号量 `sem` 的操作

		信号量的值大于 0 表示可用的资源数，小于 0 表示阻塞的进程数

		一次 `P` 操作使 `sem` 减1，一次 `V` 操作使 `sem` 加1

		`sem > 0` 时, 进程或线程具有公共资源的访问权

		`sem = 0` 时, 进程或线程处于等待状态

		`sem < 0` 时, 进程或线程会被阻塞, 直到信号量 `sem >= 0`

	<br>

3.	https://blog.csdn.net/weirdosick/article/details/53224535

4.	https://blog.csdn.net/ithomer/article/details/6063067

5.	https://linux.die.net/man/3/sem_init
